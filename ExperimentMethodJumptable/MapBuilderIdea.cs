// "Mono.Android"

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

internal partial class JavaInteropTypeMap
{
    [TypeMapFactory(nameof(DefineTypeMap))]
    public static partial JavaInteropTypeMap Create();

    // What trimmer/ilc see:
    //
    // // Methods
    // .method private hidebysig static 
    //     void BuildTypeMap (
    //         class System.Runtime.InteropServices.TypeMapBuilder builder
    //     ) cil managed 
    // {
    //     .custom instance void System.Runtime.InteropServices.TypeMapDefinition::.ctor() = (
    //         01 00 00 00
    //     )
    //     // Method begins at RVA 0x2050
    //     // Header size: 1
    //     // Code size: 56 (0x38)
    //     .maxstack 8
    //
    //     IL_0000: ldarg.0
    //     IL_0001: ldsflda uint8[] JavaInteropTypeMap/JavaClassNames::Class0
    //     IL_0006: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class0>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_000b: ldarg.0
    //     IL_000c: ldsflda uint8[] JavaInteropTypeMap/JavaClassNames::Class1
    //     IL_0011: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class1>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_0016: ldarg.0
    //     IL_0017: ldsflda uint8[] JavaInteropTypeMap/JavaClassNames::Class2
    //     IL_001c: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class2>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_0021: ldarg.0
    //     IL_0022: ldsflda uint8[] JavaInteropTypeMap/JavaClassNames::Class3
    //     IL_0027: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class3>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_002c: ldarg.0
    //     IL_002d: ldsflda uint8[] JavaInteropTypeMap/JavaClassNames::Class4
    //     IL_0032: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class4>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //              ...
    //     IL_0037: ret
    // } // end of method JavaInteropTypeMap::BuildTypeMap
    private static void DefineTypeMap(TypeMapBuilder builder)
    {
        builder.AddMapping<Class0>(JavaClassNames.Class0);
        builder.AddMapping<Class1>(JavaClassNames.Class1);
        builder.AddMapping<Class2>(JavaClassNames.Class2);
        builder.AddMapping<Class3>(JavaClassNames.Class3);
        builder.AddMapping<Class4>(JavaClassNames.Class4);
        // ...
    }

    private static class JavaClassNames
    {
        public static readonly byte[] Class0 = "JavaClass0"u8.ToArray();
        public static readonly byte[] Class1 = "JavaClass1"u8.ToArray();
        public static readonly byte[] Class2 = "JavaClass2"u8.ToArray();
        public static readonly byte[] Class3 = "JavaClass3"u8.ToArray();
        public static readonly byte[] Class4 = "JavaClass4"u8.ToArray();
    }

    // optional - in some cases we might not need the type map
    // - the body of this method will be generated by trimmer/ilc
    [GenerateNativeToManagedMapping]
    public partial Type? GetType(ReadOnlySpan<byte> key);  // (those `partials` used here are just so that I can show the idea, it would be `extern` as with [UnsafeAccessor] or just return default and  the trimmer or ILC will just replace the whole method body)

    // optional
    // - the body of this method will be generated by trimmer/ilc
    [GenerateStaticInterfaceMethodInvocation(typeof(IJavaInteropFunctionPointerResolver), nameof(IJavaInteropFunctionPointerResolver.MyMethod))]
    public partial IntPtr MyMethod(ReadOnlySpan<byte> key, int myArgument); // the signature is (TKey key[, parameter1, parameter2, ...]) - in this case the myArgument is the parameter passed to IJavaInteropMethodResolver.MyMethod 
}

// Q: Is there some thread which would discuss calling static abstract interface methods on type instances?
// something like:
//
// public IntPtr MyMethod(Type type, int myArgument) {
//    if (type is T : IJavaInteropMethodResolver) {
//          return T.MyMethod(myArgument);
//    }
//
//    return IntPtr.Zero;
// }
//
//

// generated by the trimmer or ilc during the final app build:

partial class JavaInteropTypeMap
{
    private readonly TypeIndex _typeIndex;

    public static partial JavaInteropTypeMap Create()
    {
        var precompiled = Convert.FromBase64String("KQAAABSkVDce9tUuyJglz0FDL773nUj67Hj9aHJDtU6AQaSMR8nslMrQM2aK1BeFpMYLU+EjBIS40/5P8MQ1x0DeUjnajaN99VWJfgTRpy6hTSLhRAoirhGMyk5WuJYj68VzOZ+o9dzVEN6kSeU5CckfSnW3Y3NcgWFmeWA2HJvRl0nccBoFlv6ZUSefVyTRQUzv5Ej4KlvzugOeeo6ePgbzyqu1HigxAAAAAAoAAAAUAAAAHwAAACoAAAA1AAAAQAAAAEsAAABWAAAAYQAAAGwAAAB3AAAAggAAAIwAAACXAAAAogAAAK0AAAC4AAAAwwAAAM4AAADZAAAA5AAAAO8AAAD6AAAABAEAAA8BAAAaAQAAJQEAADABAAA7AQAARgEAAFEBAABcAQAAZwEAAHIBAAB8AQAAhgEAAJABAACaAQAApAEAAK4BAABKYXZhQ2xhc3MwSmF2YUNsYXNzMUphdmFDbGFzczEwSmF2YUNsYXNzMTFKYXZhQ2xhc3MxMkphdmFDbGFzczEzSmF2YUNsYXNzMTRKYXZhQ2xhc3MxNUphdmFDbGFzczE2SmF2YUNsYXNzMTdKYXZhQ2xhc3MxOEphdmFDbGFzczE5SmF2YUNsYXNzMkphdmFDbGFzczIwSmF2YUNsYXNzMjFKYXZhQ2xhc3MyMkphdmFDbGFzczIzSmF2YUNsYXNzMjRKYXZhQ2xhc3MyNUphdmFDbGFzczI2SmF2YUNsYXNzMjdKYXZhQ2xhc3MyOEphdmFDbGFzczI5SmF2YUNsYXNzM0phdmFDbGFzczMwSmF2YUNsYXNzMzFKYXZhQ2xhc3MzMkphdmFDbGFzczMzSmF2YUNsYXNzMzRKYXZhQ2xhc3MzNUphdmFDbGFzczM2SmF2YUNsYXNzMzdKYXZhQ2xhc3MzOEphdmFDbGFzczM5SmF2YUNsYXNzNEphdmFDbGFzczVKYXZhQ2xhc3M2SmF2YUNsYXNzN0phdmFDbGFzczhKYXZhQ2xhc3M5T3RoZXJKYXZhQ2xhc3Mx");
        return new JavaInteropTypeMap(TypeIndex.Hydrate(precompiled));
    }

    private JavaInteropTypeMap(TypeIndex typeIndex) => _typeIndex = typeIndex;

    public partial Type? GetType(ReadOnlySpan<byte> key)
    {
        if (!_typeIndex.TryGetIndex(key, out var index))
            return null;

        // if there are too many types, we can split this into multiple methods
        // -> see xamarin-macios Managed static registrar docs for the details
        return index switch
        {
            0 => typeof(Class2),
            1 => typeof(Class18),
            2 => typeof(Class15),
            3 => typeof(Class16),
            4 => typeof(Class38),
            5 => typeof(Class36),
            6 => typeof(Class7),
            7 => typeof(Class31),
            8 => typeof(Class9),
            9 => typeof(Class27),
            10 => typeof(Class11),
            11 => typeof(Class21),
            12 => typeof(Class10),
            13 => typeof(Class4),
            14 => typeof(Class37),
            15 => typeof(Class30),
            16 => typeof(Class26),
            17 => typeof(Class5),
            18 => typeof(Class12),
            19 => typeof(Class32),
            20 => typeof(Class29),
            21 => typeof(Class39),
            22 => typeof(Class25),
            23 => typeof(Class1),
            24 => typeof_OtherClass,
            25 => typeof(Class0),
            26 => typeof(Class22),
            27 => typeof(Class3),
            28 => typeof(Class8),
            29 => typeof(Class14),
            30 => typeof(Class28),
            31 => typeof(Class20),
            32 => typeof(Class19),
            33 => typeof(Class6),
            34 => typeof(Class34),
            35 => typeof(Class17),
            36 => typeof(Class13),
            37 => typeof(Class33),
            38 => typeof(Class35),
            39 => typeof(Class23),
            40 => typeof(Class24),
            _ => default,
        };
    }

    // so that the type is not loaded if it's not hit and it is in another assembly?
    private static Type typeof_OtherClass => typeof(ExperimentMethodJumptable_SecondAssembly.OtherClass1);

    public partial IntPtr MyMethod(ReadOnlySpan<byte> key, int myArgument)
    {
        if (!_typeIndex.TryGetIndex(key, out var index))
        {
            Console.Write($"Type not found for key: {Encoding.UTF8.GetString(key)} :: ");
            foreach (var b in key)
            {
                Console.Write($"{b:X2} ");
            }
            Console.WriteLine();

            _typeIndex.Dump();

            return default;
        }

        // if there are too many types, we can split this into multiple methods
        return index switch
        {
            0 => MyMethod<Class2>(myArgument),
            1 => MyMethod<Class18>(myArgument),
            2 => MyMethod<Class15>(myArgument),
            3 => MyMethod<Class16>(myArgument),
            4 => MyMethod<Class38>(myArgument),
            5 => MyMethod<Class36>(myArgument),
            6 => MyMethod<Class7>(myArgument),
            7 => MyMethod<Class31>(myArgument),
            8 => MyMethod<Class9>(myArgument),
            9 => MyMethod<Class27>(myArgument),
            10 => MyMethod<Class11>(myArgument),
            11 => MyMethod<Class21>(myArgument),
            12 => MyMethod<Class10>(myArgument),
            13 => MyMethod<Class4>(myArgument),
            14 => MyMethod<Class37>(myArgument),
            15 => MyMethod<Class30>(myArgument),
            16 => MyMethod<Class26>(myArgument),
            17 => MyMethod<Class5>(myArgument),
            18 => MyMethod<Class12>(myArgument),
            19 => MyMethod<Class32>(myArgument),
            20 => MyMethod<Class29>(myArgument),
            21 => MyMethod<Class39>(myArgument),
            22 => MyMethod<Class25>(myArgument),
            23 => MyMethod<Class1>(myArgument),
            24 => throw new InvalidOperationException(), // should the whole compilation fail if any of the classes don't implement the given interface?
            25 => MyMethod<Class0>(myArgument),
            26 => MyMethod<Class22>(myArgument),
            27 => MyMethod<Class3>(myArgument),
            28 => MyMethod<Class8>(myArgument),
            29 => MyMethod<Class14>(myArgument),
            30 => MyMethod<Class28>(myArgument),
            31 => MyMethod<Class20>(myArgument),
            32 => MyMethod<Class19>(myArgument),
            33 => MyMethod<Class6>(myArgument),
            34 => MyMethod<Class34>(myArgument),
            35 => MyMethod<Class17>(myArgument),
            36 => MyMethod<Class13>(myArgument),
            37 => MyMethod<Class33>(myArgument),
            38 => MyMethod<Class35>(myArgument),
            39 => MyMethod<Class23>(myArgument),
            40 => MyMethod<Class24>(myArgument),
            _ => default,
        };

        static IntPtr MyMethod<T>(int myArgument)
            where T : IJavaInteropFunctionPointerResolver // -- this is generated based on the `Type constraint` in the attribute
        {
            Console.WriteLine($"Calling MyMethod<{typeof(T).Name}>({myArgument})");
            return T.MyMethod(myArgument);
        }
    }
}


// the runtime bits:

#pragma warning disable CS9113

namespace System.Runtime.InteropServices
{
    public sealed class TypeMapFactory(string methodName) : Attribute
    {
    }
 
    public sealed class GenerateNativeToManagedMappingAttribute : Attribute
    {
    }

    public sealed class GenerateStaticInterfaceMethodInvocationAttribute(Type constraint, string methodName) : Attribute
    {
    }

    public abstract class TypeMapBuilder
    {
        public abstract void AddMapping<T>(in byte[] key);
    }

    public sealed class TypeIndex
    {
        private PrecompiledBinarySearchIndexLookup _index;

        internal TypeIndex(PrecompiledBinarySearchIndexLookup index)
        {
            _index = index;
        }

        public bool TryGetIndex(ReadOnlySpan<byte> key, out int index)
            => _index.TryGetValue(key.ToArray(), out index);

        public static unsafe TypeIndex Hydrate(byte[] data)
        {
            // // Now let's pretend this is efficient... but solving how to store the data in the assembly somewhere
            // // so that it's loaded into memory and we can just grab a pointer to it and it won't move during the whole
            // // app lifetime is a separate problem at the moment. Copying the whole chunk of memory would slow down startup
            // // so this is definitely just a temporary defensive copy.
            // byte* nativeMemory = (byte*)NativeMemory.AllocZeroed((nuint)data.Length);
            // NativeMemory.Copy(Unsafe.AsPointer(ref data[0]), nativeMemory, (nuint)data.Length);
            // return new TypeIndex(new PrecompiledBinarySearchIndexLookup(nativeMemory, data.Length));

            return new TypeIndex(new PrecompiledBinarySearchIndexLookup(data));
        }

        public void Dump()
        {
            foreach (var (key, value) in _index)
            {
                Console.Write($"{Encoding.UTF8.GetString(key)} => {value} :: ");
                foreach (var b in key)
                {
                    Console.Write($"{b:X2} ");
                }
                Console.WriteLine();
            }

            _index.Dump();
        }
    }
}
