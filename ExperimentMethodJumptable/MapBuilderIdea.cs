// "Mono.Android"

internal partial class JavaInteropTypeMap : System.Runtime.InteropServices.TypeMap
{
    public JavaInteropTypeMap(ReadOnlySpan<byte> precompiledMap)
        : base(precompiledMap)
    {
        // body of the constructor is generated at app build time (pre-trimming)
        // - trimmer or ilc will remove the body of the constructor
        AddMapping<Class0>("JavaClass0");
        AddMapping<Class1>("JavaClass1");
        AddMapping<Class2>("JavaClass2");
        AddMapping<Class3>("JavaClass3");
        AddMapping<Class4>("JavaClass4");
        // ...
    }

    // optional
    [System.Runtime.InteropServices.GenerateNativeToManagedMapping] // - this method will be generated by trimmer/ilc
    public partial Type? GetType(string key);

    // optional
    [System.Runtime.InteropServices.GenerateMethodInvocation(nameof(GetFunctionPointerCore))] // - this method will be generated by trimmer/ilc
    public partial IntPtr GetFunctionPointer(string key, int methodKey);

    private IntPtr GetFunctionPointerCore<T>(int methodKey)
        where T : IJavaInteropMethodResolver
    {
        return T.GetFunctionPointer(methodKey);
    }
}

interface IJavaInteropMethodResolver
{
    static abstract IntPtr GetFunctionPointer(int methodKey);
}

// generated by the trimmer or ilc:
// (so those `partials` used here are just so that I can show the idea,
// it would be `extern` as with [UnsafeAccessor] or just return default and 
// the trimmer or ILC will just replace the whole method body)

partial class JavaInteropTypeMap
{
    public partial Type? GetType(string key)
    {
        if (!TryGetIndex(key, out var index))
            return null;

        // if there are too many types, we can split this into multiple methods
        // ideally per assembly? I guess that would make it really complicated to map those types to a 
        return index switch
        {
            0 => typeof_Class0, // so that the type is not loaded if it's not hit and it is in another assembly?
            1 => typeof(Class1),
            2 => typeof(Class2),
            3 => typeof(Class3),
            4 => typeof(Class4),
            // ...
            _ => default,
        };
    }

    private static Type typeof_Class0 => typeof(Class0);

    public partial IntPtr GetFunctionPointer(string key, int methodKey)
    {
        if (!TryGetIndex(key, out var index))
            return default;

        // if there are too many types, we can split this into multiple methods
        return index switch
        {
            0 => GetFunctionPointerCore<Class0>(methodKey),
            1 => GetFunctionPointerCore<Class1>(methodKey),
            2 => GetFunctionPointerCore<Class2>(methodKey),
            3 => GetFunctionPointerCore<Class3>(methodKey),
            4 => GetFunctionPointerCore<Class4>(methodKey),
            // ...
            _ => default,
        };
    }
}


partial class Class0 : IJavaInteropMethodResolver {
    static IntPtr IJavaInteropMethodResolver.GetFunctionPointer(int methodKey) => 1 * methodKey;
}

partial class Class1 : IJavaInteropMethodResolver {
    static IntPtr IJavaInteropMethodResolver.GetFunctionPointer(int methodKey) => 2 * methodKey;
}

partial class Class2 : IJavaInteropMethodResolver {
    static IntPtr IJavaInteropMethodResolver.GetFunctionPointer(int methodKey) => 3 * methodKey;
}

partial class Class3 : IJavaInteropMethodResolver {
    static IntPtr IJavaInteropMethodResolver.GetFunctionPointer(int methodKey) => 4 * methodKey;
}

partial class Class4 : IJavaInteropMethodResolver {
    static IntPtr IJavaInteropMethodResolver.GetFunctionPointer(int methodKey) => 5 * methodKey;
}



// the runtime:

namespace System.Runtime.InteropServices
{
    public sealed class GenerateNativeToManagedMappingAttribute : Attribute
    {
    }

    public sealed class GenerateMethodInvocationAttribute : Attribute
    {
        public GenerateMethodInvocationAttribute(string memberName)
        {
        }
    }

    public abstract class TypeMap
    {
        private readonly IDictionary<string, int> _indexMap;

        protected TypeMap(ReadOnlySpan<byte> definition)
        {
            // _indexMap = FrozenDictionary.Hydrate<string, int>(definition); -- this is something we don't have (yet)
            _indexMap = new Dictionary<string, int>();
        }

        protected bool TryGetIndex(string key, out int index)
            => _indexMap.TryGetValue(key, out index);

        protected void AddMapping<T>(string key)
        {
        }
    }
}
