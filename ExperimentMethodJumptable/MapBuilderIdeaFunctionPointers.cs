// "Mono.Android"

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

internal partial class JavaInteropFunctionPointerMap : TypeMap<JavaInteropFunctionPointerMap, ReadOnlySpan<byte>>
{
    // What trimmer/ilc see:
    //
    // // Methods
    // .method private hidebysig static 
    //     void BuildTypeMap (
    //         class System.Runtime.InteropServices.TypeMapBuilder builder
    //     ) cil managed 
    // {
    //     .custom instance void System.Runtime.InteropServices.TypeMapDefinition::.ctor() = (
    //         01 00 00 00
    //     )
    //     // Method begins at RVA 0x2050
    //     // Header size: 1
    //     // Code size: 56 (0x38)
    //     .maxstack 8
    //
    //     IL_0000: ldarg.0
    //     IL_0001: ldsflda uint8[] JavaInteropFunctionPointerMap/JavaClassNames::Class0
    //     IL_0006: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class0>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_000b: ldarg.0
    //     IL_000c: ldsflda uint8[] JavaInteropFunctionPointerMap/JavaClassNames::Class1
    //     IL_0011: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class1>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_0016: ldarg.0
    //     IL_0017: ldsflda uint8[] JavaInteropFunctionPointerMap/JavaClassNames::Class2
    //     IL_001c: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class2>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_0021: ldarg.0
    //     IL_0022: ldsflda uint8[] JavaInteropFunctionPointerMap/JavaClassNames::Class3
    //     IL_0027: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class3>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_002c: ldarg.0
    //     IL_002d: ldsflda uint8[] JavaInteropFunctionPointerMap/JavaClassNames::Class4
    //     IL_0032: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class4>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //              ...
    //     IL_0037: ret
    // } // end of method JavaInteropFunctionPointerMap::BuildTypeMap
    protected override void DefineTypeMap()
    {
        AddMapping<Class0>("JavaClass0");
        AddMapping<Class1>("JavaClass0");
        AddMapping<Class2>("JavaClass0");
        AddMapping<Class3>("JavaClass0");
        AddMapping<Class4>("JavaClass0");
        // ...
    }

    // the body of this method will be generated by trimmer/ilc
    [GenerateFunctionPointerGetter(typeof(IJavaInteropFunctionPointerResolver), nameof(IJavaInteropFunctionPointerResolver.MyMethod))]
    public unsafe partial delegate*<int, IntPtr> MyMethod(ReadOnlySpan<byte> key);
}

// generated by the trimmer or ilc during the final app build:

partial class JavaInteropFunctionPointerMap
{
    private readonly TypeIndex _typeIndex;

    public JavaInteropFunctionPointerMap()
    {
        // In debug builds, it could actually use `DefineTypeMap` to build the index
        // + use reflection to get the method pointers?

        // For release builds it would be sorta kinda (wihtout the Base64 encoding ofc)
        var precompiled = Convert.FromBase64String("KQAAAOEjBISK1BeFgEGkjEfJ7JRwGgWWYDYcm/O6A57VEN6kBvPKq0QKIq5BQy++8MQ1x8iYJc+fVyTR0ZdJ3J+o9dyhTSLhQUzv5PedSPpJ5TkJVriWI/6ZUScE0acuHvbVLrUeKDEUpFQ3QN5SOevFczl6jp4+ckO1ThGMyk640/5PpMYLU0j4Klu3Y3NcytAzZux4/WjJH0p1gWFmedqNo331VYl+AAAAAAoAAAAVAAAAIAAAACsAAAA2AAAAQQAAAEsAAABWAAAAYAAAAGsAAAB2AAAAgQAAAIwAAACWAAAAoQAAAKwAAAC3AAAAwQAAAMwAAADXAAAA4gAAAO0AAAD4AAAAAgEAABEBAAAbAQAAJgEAADABAAA6AQAARQEAAFABAABbAQAAZgEAAHABAAB7AQAAhgEAAJEBAACcAQAApwEAALIBAABKYXZhQ2xhc3MySmF2YUNsYXNzMThKYXZhQ2xhc3MxNUphdmFDbGFzczE2SmF2YUNsYXNzMzhKYXZhQ2xhc3MzNkphdmFDbGFzczdKYXZhQ2xhc3MzMUphdmFDbGFzczlKYXZhQ2xhc3MyN0phdmFDbGFzczExSmF2YUNsYXNzMjFKYXZhQ2xhc3MxMEphdmFDbGFzczRKYXZhQ2xhc3MzN0phdmFDbGFzczMwSmF2YUNsYXNzMjZKYXZhQ2xhc3M1SmF2YUNsYXNzMTJKYXZhQ2xhc3MzMkphdmFDbGFzczI5SmF2YUNsYXNzMzlKYXZhQ2xhc3MyNUphdmFDbGFzczFPdGhlckphdmFDbGFzczFKYXZhQ2xhc3MwSmF2YUNsYXNzMjJKYXZhQ2xhc3MzSmF2YUNsYXNzOEphdmFDbGFzczE0SmF2YUNsYXNzMjhKYXZhQ2xhc3MyMEphdmFDbGFzczE5SmF2YUNsYXNzNkphdmFDbGFzczM0SmF2YUNsYXNzMTdKYXZhQ2xhc3MxM0phdmFDbGFzczMzSmF2YUNsYXNzMzVKYXZhQ2xhc3MyM0phdmFDbGFzczI0");
        _typeIndex = TypeIndex.Hydrate(precompiled);
    }

    public unsafe partial delegate*<int, IntPtr> MyMethod(ReadOnlySpan<byte> key)
    {
        if (!_typeIndex.TryGetIndex(key, out var index))
        {
            Console.Write($"Type not found for key: {Encoding.UTF8.GetString(key)}");
            return default;
        }

        // if there are too many types, we can split this into multiple methods
        return index switch
        {
            0 => &Class2.MyMethod,
            1 => &Class18.MyMethod,
            2 => &Class15.MyMethod,
            3 => &Class16.MyMethod,
            4 => &Class38.MyMethod,
            5 => &Class36.MyMethod,
            6 => &Class7.MyMethod,
            7 => &Class31.MyMethod,
            8 => &Class9.MyMethod,
            9 => &Class27.MyMethod,
            10 => &Class11.MyMethod,
            11 => &Class21.MyMethod,
            12 => &Class10.MyMethod,
            13 => &Class4.MyMethod,
            14 => &Class37.MyMethod,
            15 => &Class30.MyMethod,
            16 => &Class26.MyMethod,
            17 => &Class5.MyMethod,
            18 => &Class12.MyMethod,
            19 => &Class32.MyMethod,
            20 => &Class29.MyMethod,
            21 => &Class39.MyMethod,
            22 => &Class25.MyMethod,
            23 => &Class1.MyMethod,
            24 => throw new InvalidOperationException(), // should the whole compilation fail if any of the classes don't implement the given interface?
            25 => &Class0.MyMethod,
            26 => &Class22.MyMethod,
            27 => &Class3.MyMethod,
            28 => &Class8.MyMethod,
            29 => &Class14.MyMethod,
            30 => &Class28.MyMethod,
            31 => &Class20.MyMethod,
            32 => &Class19.MyMethod,
            33 => &Class6.MyMethod,
            34 => &Class34.MyMethod,
            35 => &Class17.MyMethod,
            36 => &Class13.MyMethod,
            37 => &Class33.MyMethod,
            38 => &Class35.MyMethod,
            39 => &Class23.MyMethod,
            40 => &Class24.MyMethod,
            _ => default,
        };
    }
}
// the runtime bits:

#pragma warning disable CS9113

namespace System.Runtime.InteropServices
{
    using System.Diagnostics;
    using System.Reflection;

    public sealed class GenerateFunctionPointerGetterAttribute : Attribute
    {
        public GenerateFunctionPointerGetterAttribute(Type type, string memberName)
        {
            Debug.Assert(type.GetMethod(memberName, BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly) is not null);

            MemberName = memberName;
        }

        public string MemberName { get; }
    }

    public abstract class TypeMap<TTypeMap, TKey>
        where TTypeMap : new()
        where TKey : allows ref struct // allows ReadOnlySpan<byte>
    {
        protected abstract void DefineTypeMap();

        public static TTypeMap Create()
        {
            return new TTypeMap();
        }

        // This method will be fully trimmed in Release builds
        protected void AddMapping<T>(string key)
        {
        }
    }
}
