// "Mono.Android"

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

internal partial class JavaInteropFunctionPointerMap : TypeMap<Utf8BytesTypeMapKeyKind>
{
    // What trimmer/ilc see:
    //
	// // Methods
	// .method family hidebysig virtual 
	// 	instance void DefineTypeMap (
	// 		class System.Runtime.InteropServices.TypeMapBuilder2 builder
	// 	) cil managed 
	// {
	// 	// Method begins at RVA 0x27a5
	// 	// Header size: 1
	// 	// Code size: 56 (0x38)
	// 	.maxstack 8

	// 	IL_0000: ldarg.1
	// 	IL_0001: ldstr "JavaClass0"
	// 	IL_0006: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder2::AddMapping<class Class0>(string)
	// 	IL_000b: ldarg.1
	// 	IL_000c: ldstr "JavaClass1"
	// 	IL_0011: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder2::AddMapping<class Class1>(string)
	// 	IL_0016: ldarg.1
	// 	IL_0017: ldstr "JavaClass2"
	// 	IL_001c: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder2::AddMapping<class Class2>(string)
	// 	IL_0021: ldarg.1
	// 	IL_0022: ldstr "JavaClass3"
	// 	IL_0027: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder2::AddMapping<class Class3>(string)
	// 	IL_002c: ldarg.1
	// 	IL_002d: ldstr "JavaClass4"
	// 	IL_0032: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder2::AddMapping<class Class4>(string)
    //           ...
    //  IL_0037: ret
    // } // end of method JavaInteropFunctionPointerMap::BuildTypeMap
    protected override void DefineTypeMap(TypeMapBuilder2 builder)
    {
        builder.AddMapping<Class0>("JavaClass0");
        builder.AddMapping<Class1>("JavaClass1");
        builder.AddMapping<Class2>("JavaClass2");
        builder.AddMapping<Class3>("JavaClass3");
        builder.AddMapping<Class4>("JavaClass4");
        // ...
    }

    // the body of this method will be generated by trimmer/ilc
    [GenerateFunctionPointerGetter(typeof(IJavaInteropFunctionPointerResolver), nameof(IJavaInteropFunctionPointerResolver.MyMethod))]
    public unsafe partial delegate*<int, IntPtr> MyMethod(ReadOnlySpan<byte> key);
}

// generated by the trimmer or ilc during the final app build:

partial class JavaInteropFunctionPointerMap
{
    private readonly TypeIndex _typeIndex;

    public JavaInteropFunctionPointerMap()
    {
        // In debug builds, it could actually use `DefineTypeMap` to build the index
        // + use reflection to get the method pointers?

        // For release builds it would be sorta kinda (wihtout the Base64 encoding ofc)
        var precompiled = Convert.FromBase64String("KQAAAOEjBISK1BeFgEGkjEfJ7JRwGgWWYDYcm/O6A57VEN6kBvPKq0QKIq5BQy++8MQ1x8iYJc+fVyTR0ZdJ3J+o9dyhTSLhQUzv5PedSPpJ5TkJVriWI/6ZUScE0acuHvbVLrUeKDEUpFQ3QN5SOevFczl6jp4+ckO1ThGMyk640/5PpMYLU0j4Klu3Y3NcytAzZux4/WjJH0p1gWFmedqNo331VYl+AAAAAAoAAAAVAAAAIAAAACsAAAA2AAAAQQAAAEsAAABWAAAAYAAAAGsAAAB2AAAAgQAAAIwAAACWAAAAoQAAAKwAAAC3AAAAwQAAAMwAAADXAAAA4gAAAO0AAAD4AAAAAgEAABEBAAAbAQAAJgEAADABAAA6AQAARQEAAFABAABbAQAAZgEAAHABAAB7AQAAhgEAAJEBAACcAQAApwEAALIBAABKYXZhQ2xhc3MySmF2YUNsYXNzMThKYXZhQ2xhc3MxNUphdmFDbGFzczE2SmF2YUNsYXNzMzhKYXZhQ2xhc3MzNkphdmFDbGFzczdKYXZhQ2xhc3MzMUphdmFDbGFzczlKYXZhQ2xhc3MyN0phdmFDbGFzczExSmF2YUNsYXNzMjFKYXZhQ2xhc3MxMEphdmFDbGFzczRKYXZhQ2xhc3MzN0phdmFDbGFzczMwSmF2YUNsYXNzMjZKYXZhQ2xhc3M1SmF2YUNsYXNzMTJKYXZhQ2xhc3MzMkphdmFDbGFzczI5SmF2YUNsYXNzMzlKYXZhQ2xhc3MyNUphdmFDbGFzczFPdGhlckphdmFDbGFzczFKYXZhQ2xhc3MwSmF2YUNsYXNzMjJKYXZhQ2xhc3MzSmF2YUNsYXNzOEphdmFDbGFzczE0SmF2YUNsYXNzMjhKYXZhQ2xhc3MyMEphdmFDbGFzczE5SmF2YUNsYXNzNkphdmFDbGFzczM0SmF2YUNsYXNzMTdKYXZhQ2xhc3MxM0phdmFDbGFzczMzSmF2YUNsYXNzMzVKYXZhQ2xhc3MyM0phdmFDbGFzczI0");
        _typeIndex = TypeIndex.Hydrate(precompiled);
    }

    public unsafe partial delegate*<int, IntPtr> MyMethod(ReadOnlySpan<byte> key)
    {
        if (!_typeIndex.TryGetIndex(key, out var index))
        {
            Console.Write($"Type not found for key: {Encoding.UTF8.GetString(key)}");
            return default;
        }

        // if there are too many types, we can split this into multiple methods
        return index switch
        {
            0 => &Class2.MyMethod,
            1 => &Class18.MyMethod,
            2 => &Class15.MyMethod,
            3 => &Class16.MyMethod,
            4 => &Class38.MyMethod,
            5 => &Class36.MyMethod,
            6 => &Class7.MyMethod,
            7 => &Class31.MyMethod,
            8 => &Class9.MyMethod,
            9 => &Class27.MyMethod,
            10 => &Class11.MyMethod,
            11 => &Class21.MyMethod,
            12 => &Class10.MyMethod,
            13 => &Class4.MyMethod,
            14 => &Class37.MyMethod,
            15 => &Class30.MyMethod,
            16 => &Class26.MyMethod,
            17 => &Class5.MyMethod,
            18 => &Class12.MyMethod,
            19 => &Class32.MyMethod,
            20 => &Class29.MyMethod,
            21 => &Class39.MyMethod,
            22 => &Class25.MyMethod,
            23 => &Class1.MyMethod,
            24 => throw new InvalidOperationException(), // should the whole compilation fail if any of the classes don't implement the given interface?
            25 => &Class0.MyMethod,
            26 => &Class22.MyMethod,
            27 => &Class3.MyMethod,
            28 => &Class8.MyMethod,
            29 => &Class14.MyMethod,
            30 => &Class28.MyMethod,
            31 => &Class20.MyMethod,
            32 => &Class19.MyMethod,
            33 => &Class6.MyMethod,
            34 => &Class34.MyMethod,
            35 => &Class17.MyMethod,
            36 => &Class13.MyMethod,
            37 => &Class33.MyMethod,
            38 => &Class35.MyMethod,
            39 => &Class23.MyMethod,
            40 => &Class24.MyMethod,
            _ => default,
        };
    }
}
// the runtime bits:

#pragma warning disable CS9113

namespace System.Runtime.InteropServices
{
    using System.Diagnostics;
    using System.Reflection;

    public sealed class GenerateFunctionPointerGetterAttribute : Attribute
    {
        public GenerateFunctionPointerGetterAttribute(Type type, string memberName)
        {
            Debug.Assert(type.GetMethod(memberName, BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly) is not null);

            DeclaringType = type;
            MemberName = memberName;
        }

        public Type DeclaringType { get; }
        public string MemberName { get; }
    }

    public abstract class TypeMap<TKeyKind>
        where TKeyKind : TypeMapKeyKind
    {
        protected abstract void DefineTypeMap(TypeMapBuilder2 builder);
    }

    public abstract class TypeMapBuilder2
    {
        public void AddMapping<T>(string key) // where T : TManagedType -- this won't allow us to use interfaces with static abstract methods as `TManagedType` because of CS8920
        {
        }
    }

    public abstract class TypeMapKeyKind;
    public sealed class Utf8BytesTypeMapKeyKind : TypeMapKeyKind;
}
