// "Mono.Android"

using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

internal partial class JavaInteropFunctionPointerMap
{
    [TypeMapFactory(nameof(DefineTypeMap))]
    public static partial JavaInteropFunctionPointerMap Create();

    // What trimmer/ilc see:
    //
    // // Methods
    // .method private hidebysig static 
    //     void BuildTypeMap (
    //         class System.Runtime.InteropServices.TypeMapBuilder builder
    //     ) cil managed 
    // {
    //     .custom instance void System.Runtime.InteropServices.TypeMapDefinition::.ctor() = (
    //         01 00 00 00
    //     )
    //     // Method begins at RVA 0x2050
    //     // Header size: 1
    //     // Code size: 56 (0x38)
    //     .maxstack 8
    //
    //     IL_0000: ldarg.0
    //     IL_0001: ldsflda uint8[] JavaInteropFunctionPointerMap/JavaClassNames::Class0
    //     IL_0006: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class0>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_000b: ldarg.0
    //     IL_000c: ldsflda uint8[] JavaInteropFunctionPointerMap/JavaClassNames::Class1
    //     IL_0011: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class1>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_0016: ldarg.0
    //     IL_0017: ldsflda uint8[] JavaInteropFunctionPointerMap/JavaClassNames::Class2
    //     IL_001c: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class2>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_0021: ldarg.0
    //     IL_0022: ldsflda uint8[] JavaInteropFunctionPointerMap/JavaClassNames::Class3
    //     IL_0027: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class3>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //     IL_002c: ldarg.0
    //     IL_002d: ldsflda uint8[] JavaInteropFunctionPointerMap/JavaClassNames::Class4
    //     IL_0032: callvirt instance void System.Runtime.InteropServices.TypeMapBuilder::AddMapping<class Class4>(uint8[]& modreq([System.Runtime]System.Runtime.InteropServices.InAttribute))
    //              ...
    //     IL_0037: ret
    // } // end of method JavaInteropFunctionPointerMap::BuildTypeMap
    private static void DefineTypeMap(TypeMapBuilder builder)
    {
        builder.AddMapping<Class0>(JavaClassNames.Class0);
        builder.AddMapping<Class1>(JavaClassNames.Class1);
        builder.AddMapping<Class2>(JavaClassNames.Class2);
        builder.AddMapping<Class3>(JavaClassNames.Class3);
        builder.AddMapping<Class4>(JavaClassNames.Class4);
        // ...
    }

    private static class JavaClassNames
    {
        public static readonly byte[] Class0 = "JavaClass0"u8.ToArray();
        public static readonly byte[] Class1 = "JavaClass1"u8.ToArray();
        public static readonly byte[] Class2 = "JavaClass2"u8.ToArray();
        public static readonly byte[] Class3 = "JavaClass3"u8.ToArray();
        public static readonly byte[] Class4 = "JavaClass4"u8.ToArray();
    }

    // optional
    // - the body of this method will be generated by trimmer/ilc
    [GenerateFunctionPointerGetter(typeof(IJavaInteropFunctionPointerResolver), nameof(IJavaInteropFunctionPointerResolver.GetFunctionPointer))]
    public unsafe partial delegate*<int, IntPtr> GetFunctionPointer(ReadOnlySpan<byte> key);
}

// generated by the trimmer or ilc during the final app build:

partial class JavaInteropFunctionPointerMap
{
    private readonly TypeIndex _typeIndex;

    public static partial JavaInteropFunctionPointerMap Create()
    {
        var precompiled = Convert.FromBase64String("KQAAAOEjBISK1BeFgEGkjEfJ7JRwGgWWYDYcm/O6A57VEN6kBvPKq0QKIq5BQy++8MQ1x8iYJc+fVyTR0ZdJ3J+o9dyhTSLhQUzv5PedSPpJ5TkJVriWI/6ZUScE0acuHvbVLrUeKDEUpFQ3QN5SOevFczl6jp4+ckO1ThGMyk640/5PpMYLU0j4Klu3Y3NcytAzZux4/WjJH0p1gWFmedqNo331VYl+AAAAAAoAAAAVAAAAIAAAACsAAAA2AAAAQQAAAEsAAABWAAAAYAAAAGsAAAB2AAAAgQAAAIwAAACWAAAAoQAAAKwAAAC3AAAAwQAAAMwAAADXAAAA4gAAAO0AAAD4AAAAAgEAABEBAAAbAQAAJgEAADABAAA6AQAARQEAAFABAABbAQAAZgEAAHABAAB7AQAAhgEAAJEBAACcAQAApwEAALIBAABKYXZhQ2xhc3MySmF2YUNsYXNzMThKYXZhQ2xhc3MxNUphdmFDbGFzczE2SmF2YUNsYXNzMzhKYXZhQ2xhc3MzNkphdmFDbGFzczdKYXZhQ2xhc3MzMUphdmFDbGFzczlKYXZhQ2xhc3MyN0phdmFDbGFzczExSmF2YUNsYXNzMjFKYXZhQ2xhc3MxMEphdmFDbGFzczRKYXZhQ2xhc3MzN0phdmFDbGFzczMwSmF2YUNsYXNzMjZKYXZhQ2xhc3M1SmF2YUNsYXNzMTJKYXZhQ2xhc3MzMkphdmFDbGFzczI5SmF2YUNsYXNzMzlKYXZhQ2xhc3MyNUphdmFDbGFzczFPdGhlckphdmFDbGFzczFKYXZhQ2xhc3MwSmF2YUNsYXNzMjJKYXZhQ2xhc3MzSmF2YUNsYXNzOEphdmFDbGFzczE0SmF2YUNsYXNzMjhKYXZhQ2xhc3MyMEphdmFDbGFzczE5SmF2YUNsYXNzNkphdmFDbGFzczM0SmF2YUNsYXNzMTdKYXZhQ2xhc3MxM0phdmFDbGFzczMzSmF2YUNsYXNzMzVKYXZhQ2xhc3MyM0phdmFDbGFzczI0");
        return new JavaInteropFunctionPointerMap(TypeIndex.Hydrate(precompiled));
    }

    private JavaInteropFunctionPointerMap(TypeIndex typeIndex) => _typeIndex = typeIndex;

    public unsafe partial delegate*<int, IntPtr> GetFunctionPointer(ReadOnlySpan<byte> key)
    {
        if (!_typeIndex.TryGetIndex(key, out var index))
        {
            Console.Write($"Type not found for key: {Encoding.UTF8.GetString(key)}");
            return default;
        }

        // if there are too many types, we can split this into multiple methods
        return index switch
        {
            0 => &Class2.GetFunctionPointer,
            1 => &Class18.GetFunctionPointer,
            2 => &Class15.GetFunctionPointer,
            3 => &Class16.GetFunctionPointer,
            4 => &Class38.GetFunctionPointer,
            5 => &Class36.GetFunctionPointer,
            6 => &Class7.GetFunctionPointer,
            7 => &Class31.GetFunctionPointer,
            8 => &Class9.GetFunctionPointer,
            9 => &Class27.GetFunctionPointer,
            10 => &Class11.GetFunctionPointer,
            11 => &Class21.GetFunctionPointer,
            12 => &Class10.GetFunctionPointer,
            13 => &Class4.GetFunctionPointer,
            14 => &Class37.GetFunctionPointer,
            15 => &Class30.GetFunctionPointer,
            16 => &Class26.GetFunctionPointer,
            17 => &Class5.GetFunctionPointer,
            18 => &Class12.GetFunctionPointer,
            19 => &Class32.GetFunctionPointer,
            20 => &Class29.GetFunctionPointer,
            21 => &Class39.GetFunctionPointer,
            22 => &Class25.GetFunctionPointer,
            23 => &Class1.GetFunctionPointer,
            24 => throw new InvalidOperationException(), // should the whole compilation fail if any of the classes don't implement the given interface?
            25 => &Class0.GetFunctionPointer,
            26 => &Class22.GetFunctionPointer,
            27 => &Class3.GetFunctionPointer,
            28 => &Class8.GetFunctionPointer,
            29 => &Class14.GetFunctionPointer,
            30 => &Class28.GetFunctionPointer,
            31 => &Class20.GetFunctionPointer,
            32 => &Class19.GetFunctionPointer,
            33 => &Class6.GetFunctionPointer,
            34 => &Class34.GetFunctionPointer,
            35 => &Class17.GetFunctionPointer,
            36 => &Class13.GetFunctionPointer,
            37 => &Class33.GetFunctionPointer,
            38 => &Class35.GetFunctionPointer,
            39 => &Class23.GetFunctionPointer,
            40 => &Class24.GetFunctionPointer,
            _ => default,
        };
    }
}
// the runtime bits:

#pragma warning disable CS9113

namespace System.Runtime.InteropServices
{
    using System.Diagnostics;
    using System.Reflection;

    public sealed class GenerateFunctionPointerGetterAttribute : Attribute
    {
        public GenerateFunctionPointerGetterAttribute(Type type, string memberName)
        {
            Debug.Assert(type.GetMethod(memberName, BindingFlags.Public | BindingFlags.Static | BindingFlags.DeclaredOnly) is not null);

            MemberName = memberName;
        }

        public string MemberName { get; }
    }
}
